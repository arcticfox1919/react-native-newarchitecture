#pragma once

#include "CppDemoSpecJSI.h"

namespace facebook::react  {

/**
 * ═══════════════════════════════════════════════════════════════════════════
 *                    Pure C++ TurboModule Type Bridging
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * This module demonstrates React Native's New Architecture C++ bridging layer.
 * The bridging system automatically converts types between JavaScript and C++.
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                      JS → C++ (fromJs)                      │
 * ├─────────────────────────────────────────────────────────────┤
 * │  jsi::String  ──────────────────────────►  std::string      │
 * │  jsi::Number (double)  ─────────────────►  int/double/float │
 * │  jsi::Boolean  ─────────────────────────►  bool             │
 * │  jsi::Array  ───────────────────────────►  std::vector<T>   │
 * │  jsi::Object  ──────────────────────────►  std::map<K,V>    │
 * │  jsi::Function  ────────────────────────►  AsyncCallback<T> │
 * │  null/undefined  ───────────────────────►  std::nullopt     │
 * └─────────────────────────────────────────────────────────────┘
 *
 * ┌─────────────────────────────────────────────────────────────┐
 * │                      C++ → JS (toJs)                        │
 * ├─────────────────────────────────────────────────────────────┤
 * │  std::string  ──────────────────────────►  jsi::String      │
 * │  int/double/float  ─────────────────────►  jsi::Number      │
 * │  bool  ─────────────────────────────────►  jsi::Boolean     │
 * │  std::vector<T>  ───────────────────────►  jsi::Array       │
 * │  std::map<K,V>  ────────────────────────►  jsi::Object      │
 * │  std::nullopt  ─────────────────────────►  null             │
 * └─────────────────────────────────────────────────────────────┘
 *
 * Call Flow:
 * ──────────────────────────────────────────────────────────────────────────
 *   JavaScript                   Bridging Layer                    C++
 * ──────────────────────────────────────────────────────────────────────────
 *   module.method(args)  →  callFromJs<ReturnT>()  →  YourClass::method()
 *                              │                            │
 *                              ├─ fromJs<T>() converts args │
 *                              └─ toJs() converts return ◄──┘
 * ──────────────────────────────────────────────────────────────────────────
 *
 * Key Points:
 * - All type checks happen at compile time (zero runtime overhead)
 * - Use Codegen to auto-generate bridging code from TypeScript specs
 * - Custom structs require Bridging<T> specialization or Codegen
 *
 * @see react/bridging/Bridging.h for conversion implementations
 * @see https://reactnative.dev/docs/the-new-architecture/pure-cxx-modules
 */

/**
 * NativeCppDemoModule - A pure C++ TurboModule implementation
 *
 * This class inherits from NativeCppDemoCxxSpec which is generated by Codegen.
 * The Spec class handles all JS-to-C++ bridging automatically.
 *
 * Inheritance Pattern (CRTP - Curiously Recurring Template Pattern):
 * ──────────────────────────────────────────────────────────────────────────
 *   class NativeCppDemoModule : public NativeCppDemoCxxSpec<NativeCppDemoModule>
 *                                                          ^^^^^^^^^^^^^^^^^^^
 *                                         Derived class passes itself as template argument
 *
 * Why CRTP instead of virtual functions?
 * - Zero runtime overhead (no vtable lookup)
 * - Compile-time polymorphism via &T::method
 * - Methods like multiply() are NOT overrides, they are direct implementations
 *   that the base class calls via static_cast<T*>(this)->method()
 *
 * The base class (NativeCppDemoCxxSpec) uses this pattern:
 *   bridging::callFromJs<ReturnT>(rt, &T::multiply, ...)
 *                                     ^^^^^^^^^^^^
 *                                     Directly references derived class method
 *
 * Usage from JavaScript:
 *   import { multiply, formatString } from 'react-native-cxx';
 *   const result = multiply(3, 4);           // Returns 12
 *   const str = formatString("Count", 5);    // Returns "Count: 5"
 */
class NativeCppDemoModule : public NativeCppDemoCxxSpec<NativeCppDemoModule> {
public:
  NativeCppDemoModule(std::shared_ptr<CallInvoker> jsInvoker);

  /**
   * Multiplies two numbers.
   *
   * @param rt  JSI Runtime (required for all TurboModule methods)
   * @param a   First operand (JS number → C++ double)
   * @param b   Second operand (JS number → C++ double)
   * @return    Product of a and b (C++ double → JS number)
   */
  double multiply(jsi::Runtime &rt, double a, double b);

  /**
   * Formats a string with a number suffix.
   *
   * @param rt   JSI Runtime (required for all TurboModule methods)
   * @param str  Input string (JS string → C++ std::string via fromJs)
   * @param num  Number to append (JS number → C++ double)
   * @return     Formatted string (C++ std::string → JS string via toJs)
   *
   * Note: The first parameter `jsi::Runtime &rt` is always required but
   * is NOT counted in the JavaScript-facing API. So from JS perspective,
   * this method takes 2 arguments: formatString(str, num)
   */
  std::string formatString(jsi::Runtime &rt, const std::string &str, double num);

  static constexpr const char* kModuleName = "NativeCppDemoModule";
};

} // namespace facebook::react
